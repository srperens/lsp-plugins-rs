// SPDX-License-Identifier: LGPL-3.0-or-later

//! TPDF dither for bit-depth reduction.
//!
//! Triangular Probability Density Function (TPDF) dither adds noise shaped
//! as a triangular distribution, created by summing two uniform random values.
//! This decorrelates quantization error from the signal, producing a constant
//! noise floor instead of correlated distortion.

use crate::util::randomizer::Randomizer;

/// TPDF dither processor for bit-depth reduction.
///
/// Adds triangular-distribution noise scaled to the target bit depth's LSB.
/// The triangular PDF is generated by summing two independent uniform random
/// values, which yields a symmetric triangle centered at zero with amplitude
/// equal to one LSB.
///
/// # Examples
///
/// ```
/// use lsp_dsp_units::util::dither::Dither;
///
/// let mut dither = Dither::new();
/// dither.init(42);
/// dither.set_bit_depth(16);
///
/// let input = vec![0.5_f32; 64];
/// let mut output = vec![0.0_f32; 64];
/// dither.process(&mut output, &input);
/// ```
#[derive(Debug, Clone)]
pub struct Dither {
    /// Target bit depth.
    bits: u32,
    /// Amplitude of one LSB at current bit depth.
    lsb: f32,
    /// First LCG for TPDF.
    rng_a: Randomizer,
    /// Second LCG for TPDF.
    rng_b: Randomizer,
}

impl Default for Dither {
    fn default() -> Self {
        Self::new()
    }
}

impl Dither {
    /// Create a new dither processor with default settings (16-bit).
    pub fn new() -> Self {
        let mut d = Self {
            bits: 16,
            lsb: 0.0,
            rng_a: Randomizer::new(),
            rng_b: Randomizer::new(),
        };
        d.lsb = Self::compute_lsb(d.bits);
        d
    }

    /// Initialize the dither processor with the given seed.
    ///
    /// The two internal RNGs are seeded with offset values to ensure
    /// they produce independent sequences.
    ///
    /// # Arguments
    /// * `seed` - Base seed for the random number generators
    pub fn init(&mut self, seed: u32) {
        self.rng_a.init_with_seed(seed);
        self.rng_b.init_with_seed(seed.wrapping_add(0x5A5A_5A5A));
    }

    /// Set the target bit depth for dithering.
    ///
    /// Common values: 16, 20, 24. The dither amplitude is scaled to
    /// one LSB at the specified bit depth.
    ///
    /// # Arguments
    /// * `bits` - Target bit depth (clamped to 1..=32)
    pub fn set_bit_depth(&mut self, bits: u32) {
        let bits = bits.clamp(1, 32);
        self.bits = bits;
        self.lsb = Self::compute_lsb(bits);
    }

    /// Get the current bit depth.
    pub fn bit_depth(&self) -> u32 {
        self.bits
    }

    /// Process a buffer, applying TPDF dither.
    ///
    /// `dst[i] = src[i] + tpdf_noise`, where the noise has triangular
    /// distribution with amplitude equal to one LSB.
    ///
    /// # Arguments
    /// * `dst` - Destination buffer
    /// * `src` - Source buffer
    pub fn process(&mut self, dst: &mut [f32], src: &[f32]) {
        let len = dst.len().min(src.len());
        for i in 0..len {
            dst[i] = src[i] + self.generate_tpdf();
        }
    }

    /// Process a buffer in-place, applying TPDF dither.
    ///
    /// # Arguments
    /// * `buf` - Buffer to process in-place
    pub fn process_inplace(&mut self, buf: &mut [f32]) {
        for sample in buf.iter_mut() {
            *sample += self.generate_tpdf();
        }
    }

    /// Reset the RNGs to initial state.
    pub fn reset(&mut self) {
        self.rng_a.init_with_seed(0);
        self.rng_b.init_with_seed(0x5A5A_5A5A);
    }

    /// Generate a single TPDF dither sample.
    ///
    /// Sums two uniform random values in [-0.5, 0.5) to create a triangular
    /// distribution in [-1, 1), then scales by the LSB amplitude.
    fn generate_tpdf(&mut self) -> f32 {
        use crate::util::randomizer::RandomDistribution;
        let u1 = self.rng_a.random(RandomDistribution::Linear) - 0.5;
        let u2 = self.rng_b.random(RandomDistribution::Linear) - 0.5;
        (u1 + u2) * self.lsb
    }

    /// Compute the LSB amplitude for a given bit depth.
    ///
    /// For N-bit audio normalized to [-1, 1], one LSB = 2 / 2^N = 2^(1-N).
    fn compute_lsb(bits: u32) -> f32 {
        // 2^(1-bits) = amplitude of one LSB in normalized [-1,1] range
        2.0_f32 / (1u64 << bits) as f32
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_dither_default() {
        let dither = Dither::new();
        assert_eq!(dither.bit_depth(), 16);
    }

    #[test]
    fn test_set_bit_depth() {
        let mut dither = Dither::new();
        dither.set_bit_depth(24);
        assert_eq!(dither.bit_depth(), 24);
    }

    #[test]
    fn test_bit_depth_clamping() {
        let mut dither = Dither::new();
        dither.set_bit_depth(0);
        assert_eq!(dither.bit_depth(), 1);
        dither.set_bit_depth(64);
        assert_eq!(dither.bit_depth(), 32);
    }

    #[test]
    fn test_lsb_values() {
        // 16-bit: LSB = 2/65536 ~ 3.05e-5
        let lsb_16 = Dither::compute_lsb(16);
        assert!((lsb_16 - 2.0 / 65536.0).abs() < 1e-10);

        // 24-bit: LSB = 2/16777216 ~ 1.19e-7
        let lsb_24 = Dither::compute_lsb(24);
        assert!((lsb_24 - 2.0 / 16777216.0).abs() < 1e-14);

        // Higher bit depth means smaller LSB
        assert!(lsb_24 < lsb_16);
    }

    #[test]
    fn test_dither_output_noise_floor() {
        let mut dither = Dither::new();
        dither.init(42);
        dither.set_bit_depth(16);

        // Process silence
        let src = vec![0.0; 10000];
        let mut dst = vec![0.0; 10000];
        dither.process(&mut dst, &src);

        // Output should be small noise around zero
        let max_abs = dst.iter().map(|x| x.abs()).fold(0.0_f32, f32::max);
        let lsb_16 = 2.0 / 65536.0;

        // TPDF noise should be bounded by approximately 1 LSB
        assert!(
            max_abs < lsb_16 * 1.1,
            "Noise amplitude {max_abs} should be within ~1 LSB ({lsb_16})"
        );

        // Noise should not be zero (RNG is producing output)
        assert!(max_abs > 0.0, "Dither should produce non-zero noise");
    }

    #[test]
    fn test_dither_triangular_distribution() {
        let mut dither = Dither::new();
        dither.init(12345);
        dither.set_bit_depth(16);

        let n = 100_000;
        let src = vec![0.0; n];
        let mut dst = vec![0.0; n];
        dither.process(&mut dst, &src);

        // Compute mean and variance
        let mean = dst.iter().copied().sum::<f32>() / n as f32;
        let variance = dst.iter().map(|&x| (x - mean) * (x - mean)).sum::<f32>() / n as f32;

        // Mean should be approximately 0
        let lsb = 2.0 / 65536.0;
        assert!(mean.abs() < lsb * 0.1, "Mean {mean} should be near zero");

        // Variance of triangular distribution [-a, a] = a^2 / 6
        // Here a = lsb (the TPDF sum of two uniforms in [-0.5*lsb, 0.5*lsb])
        let expected_var = lsb * lsb / 6.0;
        assert!(
            (variance - expected_var).abs() < expected_var * 0.2,
            "Variance {variance} should be near {expected_var}"
        );
    }

    #[test]
    fn test_process_inplace() {
        let mut dither = Dither::new();
        dither.init(42);
        dither.set_bit_depth(16);

        let mut buf = vec![0.5; 100];
        dither.process_inplace(&mut buf);

        // All values should be close to 0.5 (offset by tiny dither noise)
        for &val in &buf {
            assert!(
                (val - 0.5).abs() < 0.001,
                "Dithered value {val} too far from 0.5"
            );
        }
    }

    #[test]
    fn test_reproducibility() {
        let mut dither_a = Dither::new();
        let mut dither_b = Dither::new();
        dither_a.init(999);
        dither_b.init(999);
        dither_a.set_bit_depth(16);
        dither_b.set_bit_depth(16);

        let src = vec![0.0; 100];
        let mut dst_a = vec![0.0; 100];
        let mut dst_b = vec![0.0; 100];
        dither_a.process(&mut dst_a, &src);
        dither_b.process(&mut dst_b, &src);

        for i in 0..100 {
            assert_eq!(dst_a[i], dst_b[i], "Sequences diverged at sample {i}");
        }
    }

    #[test]
    fn test_empty_buffer() {
        let mut dither = Dither::new();
        dither.init(42);

        let src: Vec<f32> = vec![];
        let mut dst: Vec<f32> = vec![];
        dither.process(&mut dst, &src);
        // Should not panic
    }

    #[test]
    fn test_higher_bit_depth_produces_less_noise() {
        let n = 10000;
        let src = vec![0.0; n];

        let mut dither_16 = Dither::new();
        dither_16.init(42);
        dither_16.set_bit_depth(16);
        let mut dst_16 = vec![0.0; n];
        dither_16.process(&mut dst_16, &src);

        let mut dither_24 = Dither::new();
        dither_24.init(42);
        dither_24.set_bit_depth(24);
        let mut dst_24 = vec![0.0; n];
        dither_24.process(&mut dst_24, &src);

        let rms_16 = (dst_16.iter().map(|x| x * x).sum::<f32>() / n as f32).sqrt();
        let rms_24 = (dst_24.iter().map(|x| x * x).sum::<f32>() / n as f32).sqrt();

        // 24-bit dither should have ~256x less noise than 16-bit (8 extra bits)
        assert!(
            rms_24 < rms_16 / 100.0,
            "24-bit RMS ({rms_24}) should be much smaller than 16-bit RMS ({rms_16})"
        );
    }

    #[test]
    fn test_reset_produces_deterministic_output() {
        let mut dither = Dither::new();
        dither.set_bit_depth(16);

        dither.reset();
        let src = vec![0.0; 50];
        let mut dst_a = vec![0.0; 50];
        dither.process(&mut dst_a, &src);

        dither.reset();
        let mut dst_b = vec![0.0; 50];
        dither.process(&mut dst_b, &src);

        for i in 0..50 {
            assert_eq!(
                dst_a[i], dst_b[i],
                "Reset should produce same sequence at sample {i}"
            );
        }
    }

    #[test]
    fn test_process_preserves_signal() {
        let mut dither = Dither::new();
        dither.init(42);
        dither.set_bit_depth(16);

        // Process a known signal
        let src: Vec<f32> = (0..1000).map(|i| (i as f32 / 1000.0) * 2.0 - 1.0).collect();
        let mut dst = vec![0.0; 1000];
        dither.process(&mut dst, &src);

        // Output should be close to input (dither is tiny relative to signal)
        for i in 0..1000 {
            assert!(
                (dst[i] - src[i]).abs() < 0.001,
                "Dithered signal should track input at sample {i}: src={}, dst={}",
                src[i],
                dst[i]
            );
        }
    }
}
